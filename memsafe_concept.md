# Memory Safety Concept in C++



## Концепция безопасной работы с памятью для С++

> Глобальная проблема языков C и C++ в том, что указатель на выделенный блок памяти в куче является адресом 
> в оперативной памяти и отсутствует его связь и переменными - указателями, которые находятся в локальных переменных на стеке. 
> 
> Вторая, не менее серьезная проблема, которая часто приводить к неопределенному поведению (Undefined Behaviour) 
> или гонке данных (Data Races) - это доступ к одной и той же области памяти из разных потоков одновременно.

В основе [проекта безопасной работы с памятью для С++](https://github.com/rsashka/memsafe)  лежит идея использования сильных 
и слабых указателей на выделенный блок памяти в куче и контроль времени жизни копий переменных с сильными указателями. 
Это немного похоже на концепцию [владения и заимствования из языка Rust](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html), 
но которая реализована на базе сильных и слабых ссылок (стандартных механизмов С++ *shared_ptr* и *weak_ptr*), 
и поэтому полностью совместима с последним на низком уровне.

Любые операции с данными для переменной по ссылке возможны только после её захвата, 
т.е. после преобразования слабой ссылки (*weak_ptr*) в сильную (*shared_ptr*), 
причем захват объекта межпотоковой синхронизации происходит автоматически в операторе захвата ссылки (если у переменной он используется).

Данный механизм реализован на **уровне синтаксиса** и выполняется **во время компиляции** с помощью плагина, 
тогда как в рантайме происходит только контроль идентификатора потока для однопоточных ссылок. 

### Виды переменных
Выделить или освободить участок памяти вручную нельзя. 
Выделение и освобождение памяти под объект происходит автоматически при создании/удалении переменных (на стеке или в куче), 
из-за чего переменные в программе разделятся на на два вида по времени жизни:
- Постоянные переменные  - это глобальные и статические переменные, которые создаются статически или в куче 
и сохраняют свое значение после завершения блока кода, в котором они были созданы или определены (после выхода из текущей области видимости).
- Временные (автоматические) переменные - это аргументы функций и локальные переменные, 
которые создаются и уничтожаются компилятором в автоматическом режиме. 
Временные объекты доступные только изнутри того лексического контекста, в котором они были определены. 
Такие переменные размещаются на стеке и уничтожается при выходе из блока кода, где были созданы.

В реализованной концепции безопасной работы с памятью используется несколько шаблонных классов, 
каждый из которых отвечает за свой тип переменных или определенное действие:

- VarValue - переменная по значению (variable by value) - данные хранятся непосредственно в самой переменной. 
Это переменные в их классическом понимании, когда копия переменной создает дубликат исходного значения, 
а изменение копии переменной никак не влияет на исходный оригинал. 
*Создать ссылку на переменную по значению нельзя (для этих целей нужно использовать ссылочную или защищенную переменную)*.

- VarShared - ссылочная переменная (reference variable) - в переменой находится только сильный (владеющий) 
указатель на переменную по значению, тогда как память под данные выделена статически или в общей куче. 
Копия ссылочной переменной создает копию указателя и **увеличивает счетчик владений**. 
*Ссылочная переменная предназначена для использования только в текущем потоке и не имеет встроенного механизма межпотоковой синхронизации доступа.*

- VarGuarg - защитная переменная (guard variable) - тоже ссылочная переменная, но со встроенным механизмом межпотоковой синхронизации. 
Создание копии защищенной переменной копирует только сильный указатель и **увеличивает счетчик владений**. 
*Предназначена для данных к которым можно получить доступ из разных потоков.*

- VarWeak - Переменная ссылка (link variable) - в переменой находится только слабый (не владеющий) указатель на ссылочную переменную. 
Создание копии переменной-ссылки копирует только слабый указатель **без увеличения счетчика владений**. 

- VarAuto - вспомогательный объект для доступа к данным у перечисленных выше видов переменных, 
[который предоставляет механизм в стиле RAII для владения захваченным значением на время действия ограниченного блока](https://en.cppreference.com/w/cpp/thread/lock_guard). 
*Блокировка доступа (если она требуется) и преобразование слабого указателя в сильный (т.е. фактически 
[разименование указателя](https://www.gnu.org/software/c-intro-and-ref/manual/html_node/Pointer-Dereference.html)), выполняются как одна операция.*

### Правила копирования и обработки переменных
Формализованный список правил, которые проверяются (должны проверяться) в лексическом анализаторе на основе подлючаемого плагина компилятора.
- Переменные по значению и слабые ссылки могут копироваться из одной переменной в другую без каких либо ограничений.
- Защищенная и ссылочная переменная могут быть скопированы только в локальные переменные 
более низкого лексического уровня или переданы в качестве аргумента в функцию при её вызове.
- Запрещен возврат из функций защищенных и ссылочных переменных, 
которые были переданы в качестве аргументов или со счетчиком ссылок более единицы.
- Запрещено сохранение захваченных значений как статических переменных.
- Операция [обмена значениями (swap)](https://en.cppreference.com/w/cpp/algorithm/swap) для защищенных 
и ссылочных переменных разрешены только между переменными одного лексического уровня.
  
